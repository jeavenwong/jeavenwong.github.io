<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeaven Wong</title>
  
  <subtitle>Talk is cheap. Show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-07T13:14:13.507Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jeaven Wong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于DFA的词法分析程序</title>
    <link href="http://yoursite.com/2020/05/06/%E5%9F%BA%E4%BA%8EDFA%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/05/06/%E5%9F%BA%E4%BA%8EDFA%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-05-06T04:18:56.000Z</published>
    <updated>2020-05-07T13:14:13.507Z</updated>
    
    <content type="html"><![CDATA[<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>以前简单学过编译原理的理论知识，但是由于太过抽象，平时用到的机会也不多，所以很多都遗忘了，为了能简单拾起一些最最基本的知识，于是决定写一个 Lexer 程序和 Parser程序。</p><a id="more"></a><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><strong>词法分析</strong>:<br>所谓的词法分析，就是把输入的文本(源代码)中每一个单独的字符(词素)组装成一个个单词token(语素)，这些token里可以有表示符id，标点符号，保留字，运算符等。这个过程是通过正则表达式来完成的。而词法分析器在具体的编程实现上可以先写正则表达式，然后用抽象的正则表达式来转换为nfa，再从nfa转换为dfa，实现中就使用dfa来实现分词。当然也可以直接使用高级语言的正则表达式功能，每个token都写一个正则表达式，排列匹配的正则表达式的优先级，然后每次加一长度对字符串进行匹配，但这样的话，效率可能不如直接写dfa高，所以一般词法分析都是自己人工通过预先设定的保留字，id，运算符，标点符号等词来构建dfa(确定有穷自动机)，其中涉及到的算法就是 RE -&gt; NFA -&gt; DFA 的转换算法。正则表达式引擎就是用nfa/dfa来实现的。</p><p><strong>语法分析</strong>:<br>一般文法按照表达能力接近自然语言的程度，可以分为正则文法，上下文无关文法(cfg)，上下文有关文法(csg)，递归可枚举文法。现在大多数的编程语言都是上下文有关语法(全局变量)，但语法分析的时候都使用上下文无关文法来进行分析。语法分析的输入就是词法分析得到的token序列，通过自己构造的上下文无关文法来对token序列进行语法分析。有两种思路，第一种分析思路是从顶向下分析，即推导，即从非终结符开始推导，看看能不能根据规定的文法从非终结符推导出给定的句子，如果可以推导出那就是符合规定的文法，这个句子就是语法正确的。这个自顶向下分析的过程可以基于数据表驱动来进行分析，也可以使用简单粗暴的递归下降法进行分析，本质都是基于栈的分析。第二种分析思路是，从底向上分析，即规约，看看是否可以由句子来根据规定的文法来规约到非终结符。一般，parser的具体实现中，第一种思路实现起来更加方便快速，所以现在大多数的编程语言的语法分析都是自顶向下分析的。第一种中比较简单也最常用的就是使用LL(1)型文法来进行语法分析，c语言就使用可回溯的LL(1)型文法进行分析，但LL(1)要求一般不能出现左递归。如果第二种的话，常用的是LR型文法及算法，如果第一种思路无法解决语法分析的话就使用LR算法。一般来说，语法分析可以一边分析一边递归的构造出每个ast节点，最终分析结束可以得到一颗ast(抽象语法树)。之后，可以直接对ast解释执行，也可以通过ast生成中间表示IR，前者做法简单快速但速度效率可能较慢，后者做法就是解释器常见的做法，IR一般可以是字节码，比如java的字节码，然后由jvm解释执行。</p><p><strong>语义分析:</strong><br>对上一步语法分析得到的ast进行分析，做一些操作，比如类型检查等。验证符合语法的句子是否符合上下文语义。</p><p><strong>代码优化:</strong><br>可以省去，大概是可以根据代码对一些冗余或者重复的代码进行优化，还有寄存器级别的优化等。</p><p><strong>代码生成:</strong><br>进行完语义分析后，根据ast可以进行递归下降生成到目标语言，如果直接生成机器语言，那需要对二进制格式以及寄存器很熟。</p><p><strong>自动分析工具</strong>:<br>主语言是java，可以玩一下antlr。</p><h4 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h4><p>其实在学习生活过程中遇到编译知识的几率还是蛮高的（除了专业编译器研究人员和使用词法语法分析的工具外），比如，正则表达式，DFA（确定的有穷自动机）这些在一些常见算法（如KMP算法）里都多多少少会有所体现。再比如，在笔者本科的时候，数电里很经典的有穷状态机（FSM）其实就是 DFA，还有用 Verilog HDL 写 FPGA 的实验中经常需要自己构建有穷的状态，这也是 DFA 的应用。正则表达式就不用提了，应用就太广了，相信没有人没有接触过 RE（正则表达式）。</p><p>为了简单起见，使用正则表达式来做字符串中关键字的匹配，以及使用 DFA 来分析词素构建 token 语素。词法分析结束之后我会选择 CFG（上下文无关语法）中最常见最简单的没有左递归的 LL(1) 型文法来做语法分析，做法尽可能的简单，可以选择直接基于数据表来做，也可能会使用递归下降法来做解析。语法分析结束可以输出一个语法分析树。</p><p>知乎某位大佬曾经说过，如果一个程序员不是专门做编译器的开发工作，那他 对编译原理主要掌握以下几点就够用了：词法分析方面，掌握正则表达式，了解dfa/nfa。Parsing 方面，能读懂 BNF，知道AST，会写简单的递归下降 parser，会用 antlr 之类的 parser generator。 优化方面，知道现代编译器的优化能力有多强，知道如何配合编译器写出高效易读的代码，避免试图outsmart编译器。会实现简单的虚拟机（stack-based，不带GC），并把四则运算表达式翻译为虚拟机指令。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>实现了一个四则运算的解释器，即仅支持 + - * / 等四个二元运算符，然后不支持定义变量，支持数字，包括浮点数和整数。 </p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5><p>词法分析使用的是正则文法，也就是正则表达式，所以先写出需要使用的正则表达式，然后再根据正则表达式构造出 NFA ，之后再将NFA转化为 DFA ，依据  DFA  进行状态机的编码，就可以读入输入文件进行词法分析了。其实正则表达式构造 NFA 的算法是比较麻烦的，但是这里不支持保留字，标识符，标点符号等，所以分词比较简单，下面直接可以画出 DFA。</p><p><img src="/2020/05/06/%E5%9F%BA%E4%BA%8EDFA%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/DFA.jpg" alt="DFA图示"></p><p>下面是词法分析程序的输入，也是整个程序的输入。</p><p><img src="/2020/05/06/%E5%9F%BA%E4%BA%8EDFA%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5.jpg" alt="词法分析程序输入"></p><p>下面是词法分析程序的输出，即 token（语素） 序列。</p><p><img src="/2020/05/06/%E5%9F%BA%E4%BA%8EDFA%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/tokens.jpg" alt="输出Token"></p><h5 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h5><p>语法分析程序的输入是词法分析程序的输出，即 token 序列。</p><p>不考虑语法制导翻译的话，语法分析输出的都应该是一颗抽象语法树 AST ，这个结构比较抽象。下面我手画一个。</p><p><img src="/2020/05/06/%E5%9F%BA%E4%BA%8EDFA%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/AST.jpg" alt="AST结构图"></p><p>语法分析中，最麻烦的莫过于构造 LL(1) 文法了，如下图所示。</p><p><img src="/2020/05/06/%E5%9F%BA%E4%BA%8EDFA%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/LL(1)%E6%96%87%E6%B3%95%E6%9E%84%E9%80%A0.jpg" alt="LL(1)文法构造"></p><p>语法分析中如果遇见语法错误会进行错误的提示，然后表明当前的代码是语法错误的，比如我刻意去掉上面输入的表达式中的右括号，程序结果如下图所示。</p><p><img src="/2020/05/06/%E5%9F%BA%E4%BA%8EDFA%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF.jpg" alt="语法错误"></p><p>当语法分析正确后，表明我们的表达式是符合语法的，之后我们可以根据这颗 AST 来做任何操作，比如可以由前序遍历得到正序的token序列，后序遍历可以得到逆波兰表达式，可以用来模拟基于栈进行程序的执行。理论上，AST 可以转化为任何一种IR（中间表示），比如转化为 java 字节码，由 JVM 解释执行，也可以直接用 AST 解释执行。</p><p>最后就是用代码简单的模拟一下 Stack-Based VM （这类虚拟机的代表就是JVM），然后基于栈来执行指令代码，即用逆波兰表达式进和栈进行计算。</p><p>下图是 VM 程序执行指令的输出。</p><p><img src="/2020/05/06/%E5%9F%BA%E4%BA%8EDFA%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="运行结果"></p><h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h4><p>我觉得整个过程中，写 DFA 来词法解析很死板，在实际中应该会基于正则表达式来进行 DFA 的生成，龙书那么复杂的过程其实也是用来写生成词法分析程序的工具。做语法分析的难点就是构造LL(1)文法，而且还得消除左递归，否则不能用递归下降法进行文法分析，还有更麻烦的语法分析的方法就是对语法进行Fisrt-Fellow集分析得到一个预测表（parser table），根据表来进行文法分析，输入是文法规则文件和表文件，相比较之下，递归下降法更加简单高效。这个项目非常简单，但作为简单实践下编译原理的理论知识还是可以的，麻雀虽小五脏俱全嘛。但是本项目其实只是做了编译器的前端，后端的代码优化和代码生成和汇编指令啥的对于我这样的后端程序员也很重要。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>我将源代码放在了 gitee 上面，仓库链接如下。</p><p><a href="https://gitee.com/jeavenwong/SimpleJInterpreter/tree/master" target="_blank" rel="noopener"> https://gitee.com/jeavenwong/SimpleJInterpreter/tree/master </a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h4&gt;&lt;p&gt;以前简单学过编译原理的理论知识，但是由于太过抽象，平时用到的机会也不多，所以很多都遗忘了，为了能简单拾起一些最最基本的知识，于是决定写一个 Lexer 程序和 Parser程序。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="编译原理" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="词法分析" scheme="http://yoursite.com/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring Aspect失效排查记录</title>
    <link href="http://yoursite.com/2020/03/29/Spring-Aspect%E5%A4%B1%E6%95%88%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/03/29/Spring-Aspect%E5%A4%B1%E6%95%88%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/</id>
    <published>2020-03-29T04:39:40.000Z</published>
    <updated>2020-03-29T05:22:46.671Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一个低级错误导致 sping boot 切面失效的bug。</p><a id="more"></a><p>在使用Spring Aspect拦截Controller某方法打印日志的时候，突然发现AOP失效了，拦截方法正常执行，但是定义的切面并没有正常执行，IDEA 里面没有提示任何错误信息，可以引用到被拦截的目标方法上去。仔细检查了一遍代码，发现切面定义的类不是Class，而是Aspect。</p><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>我使用 maven 导入了AOP之后，在创建新的切面类的时候，点了创建Aspect。</p><p><img src="/2020/03/29/Spring-Aspect%E5%A4%B1%E6%95%88%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/introduce_aop_support.JPG" alt="introduce_aop_support"></p><p><img src="/2020/03/29/Spring-Aspect%E5%A4%B1%E6%95%88%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/abnormal_create_aspect.png" alt="abnormal_create_aspect"></p><p>然后创建的不是Class，而是Aspect…这就导致了代码没问题但是却无效的bug。</p><h4 id="反思："><a href="#反思：" class="headerlink" title="反思："></a>反思：</h4><p>在找到错误后，将 “ Aspect “ 改为 “ Class ”后，切面可以正常生效。</p><p><img src="/2020/03/29/Spring-Aspect%E5%A4%B1%E6%95%88%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/spring_boot_introduce_aop_auto.JPG" alt="spring_boot_introduce_aop_auto"></p><p>如上图所示，spring-boot-starter-aop 引入了一系列的依赖，这些依赖相当于是 IDEA 的对Aspect的增强插件，IDEA 可以在新建文件时提供一个直接创建 Aspect 的选项，但是不能用 javac 编译器进行编译，要使用 Ajc 编译器，需要在 IDEA compliler 设置里指定 Ajc 的文件位置。</p><p><img src="/2020/03/29/Spring-Aspect%E5%A4%B1%E6%95%88%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/aspect_plugin_config.png" alt="aspect_plugin_config"></p><p>指定 Ajc 编译器后按照 Aspect 的语法写好后编译运行。</p><p>至此，我把 “ Aspect “ 改为 “ Class “就可以使切面生效了。</p><p><img src="/2020/03/29/Spring-Aspect%E5%A4%B1%E6%95%88%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/normal_aspect.JPG" alt="normal_aspect"></p><p>这里还需要注意的一点是：</p><p>spring boot 在使用 Aspect 类大的时候，如果使用 @Aspect 这样的 Java Config 的方式而不使用 XML 来配置切面的话，就需要额外的在切面类的加上 @component 注解，这个如果没有加上，也会导致spring boot找不到切面类的 bean。</p><p>加 @component 的原因官方解释如下：</p><p><em>You may register aspect classes as regular beans in your Spring XML configuration, or autodetect them through classpath scanning - just like any other Spring-managed bean. However, note that the @Aspect annotation is not sufficient for autodetection in the classpath: For that purpose, you need to add a separate @Component annotation (or alternatively a custom stereotype annotation that qualifies, as per the rules of Spring’s component scanner).</em></p><p><em>您可以在Spring XML配置中注册aspect类，或者通过类路径扫描自动检测它们，就像任何其他Spring管理bean一样。但是，请注意，@aspect注释对于在类路径中自动检测是不够的：为了达到这个目的，您需要添加一个单独的@component注解（或者根据Spring的组件扫描器的规则来定义一个定制的原型注解）。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录一个低级错误导致 sping boot 切面失效的bug。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Aspect" scheme="http://yoursite.com/tags/Aspect/"/>
    
  </entry>
  
  <entry>
    <title>simple study the principle of git</title>
    <link href="http://yoursite.com/2020/03/28/simple-study-the-principle-of-git/"/>
    <id>http://yoursite.com/2020/03/28/simple-study-the-principle-of-git/</id>
    <published>2020-03-28T08:26:12.000Z</published>
    <updated>2020-03-28T09:29:33.502Z</updated>
    
    <content type="html"><![CDATA[<p>git 作为程序员经常使用的分布式版本控制工具，知其然也应该知其所以然，所以我们来浅谈下git的原理。</p><p><em>申明：本文不是原创，更多的记录下 git 的知识，文章尾部有参考文章链接。</em></p><a id="more"></a><p>我们经常使用的命令有如下几个：</p><p><code>git pull</code></p><p><code>git clone</code></p><p><code>git add</code> </p><p><code>git commit</code> </p><p><code>git push</code></p><p><code>...</code></p><p>那我们就选择几个关键且常用的命令来探究下内部的原理。</p><p>git 的基本对象有三个，blob 对象，tree 对象和 commit 对象，这个可以了解下。</p><p>git 的工作空间，暂存区和git仓库等概念可以自行了解下，如图所示。</p><p><img src="/2020/03/28/simple-study-the-principle-of-git/git_workspace_show.JPG" alt="git_workspace_show"></p><p>这是一个使用 git 管理的项目目录，你可以认为，其中 .git 目录就是本地 git 仓库。而 .git 目录下的index 就是工作暂存区。目录中除 .git 以外的空间就是用户工作目录，是用户在操作系统的文件目录下可以实实在在操作的文件集。</p><p>假设工作空间里有我们创建编辑好的各个文件，当我们执行 <code>git add .</code>命令后，git 本地仓库中会多出来一些 Blob 对象。</p><p><img src="/2020/03/28/simple-study-the-principle-of-git/p1s1.png" alt="blob object"></p><p>这些 blob 对象的内容是对用户空间里文件内容进行二进制加密压缩，而 blob 对象的名字就是文件内容的 sha1 算法得到大的 hash 值（这个也是每个 blob 对象唯一的ID）。</p><p>接着，我们执行 <code>git commit -m &#39;test&#39;</code>命令。</p><p><img src="/2020/03/28/simple-study-the-principle-of-git/p1s2.png" alt="tree object"></p><p>执行完 <code>git commit</code>命令后，首先会在 git 仓库里创建一个对应当前 blob 对象的 目录结构的 tree  对象。tree 对象的内容是一个目录索引，存放的是指向的各个 blob 对象的 ID ，还有 blob 对象对应的工作空间文件的名字和权限等信息。tree 对象的 ID 就是 tree 对象的内容的 hash 值。</p><p>然后，git 还会在 git 仓库里创建一个 commit 对象。</p><p><img src="/2020/03/28/simple-study-the-principle-of-git/p1s3.png" alt="commit object"></p><p>这个 commit 对象可以看作是当前项目的一个快照（snapshot），每个 commit 对象里都对应着一个版本，实际上，git 就是通过操作 “commit 链” 来进行版本的切换的。commit 对象里存放的是 tree 对象的信息，当前认证的作者的信息，提交者的信息以及提交 commit 的内容等。commit 对象的 ID 是commit 对象内容的 hash 值。</p><p>当然，如下图所示，git 对 commit 的操作是通过分支来进行的，所以会有分支来指向 commit 对象，master 默认是主分支。</p><p><img src="/2020/03/28/simple-study-the-principle-of-git/p1s4.png" alt="head_master_show"></p><p>至此，git 的基本原理就大致略知一二了， git是储存一个文件的内容、目录结构、commit信息和分支的。<strong>其本质上是一个key-value的数据库加上默克尔树形成的有向无环图（DAG）</strong> ，对 git 的版本控制就是在 ”commit 链“上来回移动。</p><p>下图展示了 git 操作的完整过程。</p><p><img src="/2020/03/28/simple-study-the-principle-of-git/p2s3.gif" alt="dynamic process of git"></p><p>非常有意思的是，git 采用默克尔树的结构可以防止被人篡改文件，任何人想要更改其中某个文件而不被其他人发现的话，就必须得篡改 git 仓库中所有的文件，因为所有的文件的 ID 也就是 hash 值都是关联在一起。当然，如果有人对你远端的 git中央仓库 执行了 <code>git pull</code>  或者 <code>git clone</code> 命令，那他就有了一个完整的未被篡改的 git 仓库，这样就构成了分布式。这样的设计也决定了基本没人可以恶意篡改一个有影响力的 git 仓库，即使未经说明篡改了历史被人发现，那也会遭到别人的鄙视。</p><p>git 的原理其实很复杂，指令也相当繁杂，如果想要深入学习 git 的原理，那就得花更多得时间去看书和思考。</p><p>大家一致认同的剖析 git 原理的好书，<a href="https://book.douban.com/subject/3420144/" target="_blank" rel="noopener">《Pro Git》</a></p><p>本文基本是全部借鉴了 <a href="https://www.lzane.com/" target="_blank" rel="noopener">lazne大佬</a>的这篇文章中的图。这篇文章讲的深入浅出，<a href="https://www.lzane.com/tech/git-internal/" target="_blank" rel="noopener">参考文章传送门</a>。</p><p>还有bilibili讲解的视频：<a href="https://www.bilibili.com/video/BV1RJ411X7kh" target="_blank" rel="noopener">探究git原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git 作为程序员经常使用的分布式版本控制工具，知其然也应该知其所以然，所以我们来浅谈下git的原理。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;申明：本文不是原创，更多的记录下 git 的知识，文章尾部有参考文章链接。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Use Valine and LeanCloud to build Comment System</title>
    <link href="http://yoursite.com/2020/03/28/Use-Valine-and-LeanCloud-to-build-Comment-System/"/>
    <id>http://yoursite.com/2020/03/28/Use-Valine-and-LeanCloud-to-build-Comment-System/</id>
    <published>2020-03-28T06:57:44.000Z</published>
    <updated>2020-03-28T13:52:46.992Z</updated>
    
    <content type="html"><![CDATA[<p>原始的hexo的模板landscape是没有评论系统的，我们可以自己定制一个评论系统。</p><a id="more"></a><p>可以使用 github 或者 gitee（码云）建一个第三方应用来做博客系统，但是样式不够简洁，而且评论者需要登录 github 或者 gitee账号，这里我们选用一个免费的开源博客系统 Valine，并且 Valine 默认使用云存储平台 LeanCloud 来做评论的存储，LeanCloud的开发版的存储是免费的。</p><p>Valine 的初始配置详细见官网：</p><p>注册 LeanCloud 并获得了 AppID 和 AppKey 之后就可以对 landscape 进行配置了。</p><p>编辑 <code>/themes/landscape/layout/_partial/</code>目录下的<code>article.ejs</code>，将原本配置gitment时添加在最后的那段代码删掉，添加： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index)&#123; %&gt;</span><br><span class="line">  &lt;% <span class="keyword">if</span> (post.comments)&#123; %&gt;</span><br><span class="line">    &lt;div id=<span class="string">"vcomments"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="/</span><span class="regexp">/cdn1.lncld.net/</span><span class="keyword">static</span>/js/<span class="number">3.0</span><span class="number">.4</span>/av-min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">        new Valine(&#123;</span></span><br><span class="line"><span class="string">            el: '#vcomments',</span></span><br><span class="line"><span class="string">            appId: '你的appid',</span></span><br><span class="line"><span class="string">            appKey: '你的appkey',</span></span><br><span class="line"><span class="string">            notify:true, </span></span><br><span class="line"><span class="string">            verify:true, </span></span><br><span class="line"><span class="string">            visitor:true,</span></span><br><span class="line"><span class="string">            avatar:'mm', </span></span><br><span class="line"><span class="string">            placeholder: '嘻嘻嘻' </span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;% &#125; else &#123; %&gt;</span></span><br><span class="line"><span class="string">    &lt;div class="</span>vcomments<span class="string">"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p>之后，用 hexo 重新编译然后上传到 gitee pages 即可。</p><p>运行效果图如下：</p><p><img src="/2020/03/28/Use-Valine-and-LeanCloud-to-build-Comment-System/valine_demo.JPG" alt="效果图"></p><p>参考链接：<a href="https://www.cnblogs.com/zmj97/p/10180732.html" target="_blank" rel="noopener">将hexo的评论系统由gitment改为Valine</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原始的hexo的模板landscape是没有评论系统的，我们可以自己定制一个评论系统。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>如何使用hexo发布文章</title>
    <link href="http://yoursite.com/2020/03/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/"/>
    <id>http://yoursite.com/2020/03/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/</id>
    <published>2020-03-28T00:44:52.000Z</published>
    <updated>2020-03-29T02:47:10.795Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>​    个人博客的好处多多，不仅可以记录下自己的学习过程中的踩坑经历，也可以写下自己的所思所想。</p><a id="more"></a><p>搭建博客的方式其实很多，比如，本人是主攻 Java Web后端方向，可以采用 Spring Boot + MyBatis + Mysql + Docker 来搭建博客后台，用 jQuery/Bootstrap/Vue.js + node.js 来做博客的前台，这样的技术栈来实现一个单机版的个人博客的难度应该不会很大，主要就是付出时间和精力来coding 和 debug。但是考虑到要配置部署博客，购买服务器、域名，甚至购买HTTPS的证书等，这些都是需要投入钱和时间来做，出了问题还得定位问题来 debug，还得做好博客备份。所以个人感觉要维护一个高质量的个人博客要花费很多精力和金钱，这性价比并不高。</p><p>​    国内有很多优秀的博客平台，博客园 / CSDN  等，CSDN 不仅广告多，而且这几年质量下滑的严重，博客园允许个人定制页面的样式，但是定制受限，往往也不够简洁。出于想要做一个没有侧边栏广告且简洁明了的个人博客的初衷，选定了 github pages 来托管自己的静态博客，可是国内访问 github 的速度受限，为了体验更好于是选择了相似的国产的 gitee pages 来托管博客，Hexo 是一个比较成熟的博客框架，gitee pages 也支持，可以实现静态博客的 SSR (Server Side Render)。</p><p>​    本文就记录下日常使用hexo的方式。</p><p>首先在本地安装node.js，之后安装包管理器npm，这里省略具体过程</p><ol><li><p>使用npm下载hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo</span><br></pre></td></tr></table></figure></li><li><p>用hexo生成博客根目录的source/_post目录下新的markdown文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new</span><br></pre></td></tr></table></figure><p> 或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n</span><br></pre></td></tr></table></figure></li><li><p>编辑生成的 markdown 文件的内容即可，这里推荐 Typora 软件</p><p>在 blog 根目录下的 _config.yml 把 post_asset_foler:false 修改为 true 后，上一步会生成一个同名文件夹，在里面可以放置图片素材</p><p>因为下载了如下相关插件，所以引用直接是图片名称即可，如 test.jpg 而不是 xxx/test.jpg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>记得在发布文章的时候如果想要在主页显示折叠的文章，记得在 md 文件里添加下面的标签</p><p>hex o提供的   <code>&lt;!-- more --&gt;</code>  </p><p><em>注意：不能写在除了标题外的正文第一行，否则无效</em></p><p><img src="/2020/03/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/more_essay_test.JPG" alt="折叠文章操作图"></p><p><img src="/2020/03/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/more_essay_show.JPG" alt="折叠文章效果图"></p></li><li><p>清空之前生成的 css 等样式文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li><li><p>生产新的样式文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></li><li><p>部署文章同步到 gitee pages 仓库的 {username} 仓库上即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></li><li><p>如果想要在本地预览的话，可以执行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p> 或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>我在 gitee 新建了一个 <a href="https://gitee.com/jeavenwong/blog" target="_blank" rel="noopener">repo</a> 来同步自己本地的 blog 文件，所以得记得及时 push.</p><p>如下图所示</p><p><img src="/2020/03/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/hexo_server_demo.JPG" alt="hexo_server_demo"></p><p>之后在浏览器输入localhost:4000即可在本地预览博客</p><p><img src="/2020/03/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/chrome_access_demo.JPG" alt="chrome_access_demo"></p></li></ol><p>这里吐槽一下，虽然在国内访问 gitee 比 github 快，但是 gitee 个人版每次从本地同步博客之后，都需要在 <a href="https://gitee.com/jeavenwong/jeavenwong" target="_blank" rel="noopener">gitee page 应用</a> 仓库里手动点击 pages 服务来进行更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h6&gt;&lt;p&gt;​    个人博客的好处多多，不仅可以记录下自己的学习过程中的踩坑经历，也可以写下自己的所思所想。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="发布博客" scheme="http://yoursite.com/tags/%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>我的个人博客</title>
    <link href="http://yoursite.com/2020/03/27/hello-world/"/>
    <id>http://yoursite.com/2020/03/27/hello-world/</id>
    <published>2020-03-27T14:35:33.423Z</published>
    <updated>2020-05-08T02:35:48.387Z</updated>
    
    <content type="html"><![CDATA[<p>使用 gitee pages 或者 github pages 挂自己的博客的主要初衷，就是因为简洁可定制。</p><a id="more"></a><p>我喜欢看的两个大佬的博客，收藏一下 URL 。</p><p>第一个是 vczh ，江湖人称 “轮子哥”，他对编译原理理解的深度非常人所及，他的博客中关于编译原理的博文结合具体实例，写的很好。</p><p>链接：<a href="http://www.cppblog.com/vczh/" target="_blank" rel="noopener"> http://www.cppblog.com/vczh/ </a></p><p>第二个是王垠，非常有个性，争议也很大，对 PL 的研究非常深入，对计算机的一些知识的研究也很深入，会结合自己的理解进行一些输出，可以看看他的博文提高思想深度。</p><p>链接：<a href="http://www.yinwang.org/" target="_blank" rel="noopener"> http://www.yinwang.org/ </a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 gitee pages 或者 github pages 挂自己的博客的主要初衷，就是因为简洁可定制。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="默认hexo模板landscape" scheme="http://yoursite.com/tags/%E9%BB%98%E8%AE%A4hexo%E6%A8%A1%E6%9D%BFlandscape/"/>
    
  </entry>
  
</feed>
